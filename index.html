<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一个渣渣码农"><title>CoderDp | 一个渣渣码农</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CoderDp</h1><a id="logo" href="/.">CoderDp</a><p class="description">一个渣渣码农</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/log/"><i class="fa fa-archive"> 文章</i></a><a href="/about/"><i class="fa fa-user"> 关于我</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"><a href="/2018/01/29/搭梯子系列/">搭梯子系列</a></h1><div class="post-meta">2018-01-29</div><div class="post-content"><h2><span id="前提">前提</span></h2><blockquote>
<p>申请云服务需要绑定自己的信用卡只能V卡和M卡，JCB的不知道是否支持。LZ是使用的招商银行的信用卡。卡是否支持Visa看信用卡正面的图标 ps: 申请过程中会扣1美元，但是之后会返回来。</p>
</blockquote></div><p class="readmore"><a href="/2018/01/29/搭梯子系列/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2018/01/29/随笔/">Newtonsoft.Json 序列化时，让键变成小写</a></h1><div class="post-meta">2018-01-29</div><div class="post-content"><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JsonConvert.SerializeObject(obj, <span class="keyword">new</span> <span class="type">JsonSerializerSettings</span> &#123; ContractResolver = <span class="keyword">new</span> <span class="type">CamelCasePropertyNamesContractResolver</span>() &#125;));</span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2018/01/29/随笔/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2018/01/29/原型模式/">装饰模式</a></h1><div class="post-meta">2018-01-29</div><div class="post-content"><blockquote>
<p>原型模式是创建型模式的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。<br>原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。</p></div><p class="readmore"><a href="/2018/01/29/原型模式/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2018/01/29/工厂方法模式/">工厂方法模式</a></h1><div class="post-meta">2018-01-29</div><div class="post-content"><blockquote>
<p>工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。</p>
<p>##工厂方法模式 VS 简单工厂模式<br>简单工厂的模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择动态的实例化相关的类。对于客户端来说，去除了与具体产品的依赖。<br>工厂方法模式，定义了一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使得一个类的实例化延迟到其子类。工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在。工厂方法把简单工厂内部的逻辑判断移到了客户端来进行。如果你需要加功能，本来是需要修改工厂的，现在需要修改客户端。<br> <a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">维基百科-工厂方法模式</a></p></div><p class="readmore"><a href="/2018/01/29/工厂方法模式/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2018/01/29/代理模式/">代理模式</a></h1><div class="post-meta">2018-01-29</div><div class="post-content"><blockquote>
<p>代理者是指一个类别可以作为其它东西的接口。代理者可以作任何东西的接口：网络连接、内存中的大对象、文件或其它昂贵或无法复制的资源。<br> <a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">维基百科-代理模式</a></p></div><p class="readmore"><a href="/2018/01/29/代理模式/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2018/01/29/装饰模式/">装饰模式</a></h1><div class="post-meta">2018-01-29</div><div class="post-content"><blockquote>
<p>装饰模式，是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。<br>通过使用装饰模式，可以在运行时扩充一个类的功能。原理是：增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。<br>修饰模式是类继承的另外一种选择。类继承在编译时候增加行为，而装饰模式是在运行时增加行为。<br>当有几个相互独立的功能需要扩充时，这个区别就变得很重要。在有些面向对象的编程语言中，类不能在运行时被创建，通常在设计的时候也不能预测到有哪几种功能组合。这就意味着要为每一种组合创建一个新类。相反，修饰模式是面向运行时候的对象实例的,这样就可以在运行时根据需要进行组合。<br> <a href="https://zh.wikipedia.org/wiki/%E4%BF%AE%E9%A5%B0%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">维基百科-修饰模式</a></p></div><p class="readmore"><a href="/2018/01/29/装饰模式/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2018/01/29/五大原则/">五大原则</a></h1><div class="post-meta">2018-01-29</div><div class="post-content"><h1><span id="单一功能原则">单一功能原则</span></h1><blockquote>
<p>在面向对象编程领域中，单一功能原则（Single responsibility principle）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。<br>这个术语由罗伯特·C·马丁（Robert Cecil Martin）在他的《敏捷软件开发，原则，模式和实践》一书中的一篇名为〈面向对象设计原则〉的文章中给出。 [1] 马丁表述该原则是基于的《结构化分析和系统规格》[2]一书中的内聚原则（Cohesion）上。<br>马丁把功能（职责）定义为：“改变的原因”，并且总结出一个类或者模块应该有且只有一个改变的原因。<br>一个具体的例子就是，想象有一个用于编辑和打印报表的模块。这样的一个模块存在两个改变的原因。<br>第一，报表的内容可以改变（编辑）。<br>第二，报表的格式可以改变（打印）。这两方面会的改变因为完全不同的起因而发生：一个是本质的修改，一个是表面的修改。单一功能原则认为这两方面的问题事实上是两个分离的功能，因此他们应该分离在不同的类或者模块里。把有不同的改变原因的事物耦合在一起的设计是糟糕的。<br>保持一个类专注于单一功能点上的一个重要的原因是，它会使得类更加的健壮。继续上面的例子，如果有一个对于报表编辑流程的修改，那么将存在极大的危险性，打印功能的代码会因此不工作，假使这两个功能存在于同一个类中的话。<br> <a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">维基百科-单一功能原则</a></p></div><p class="readmore"><a href="/2018/01/29/五大原则/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2018/01/29/策略模式/">策略模式</a></h1><div class="post-meta">2018-01-29</div><div class="post-content"><blockquote>
<p>策略模式作为一种软件设计模式，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。比如每个人都要“交个人所得税”，但是“在美国交个人所得税”和“在中国交个人所得税”就有不同的算税方法。<br>策略模式的特点:<br>1.定义了一族算法（业务规则）；<br>2.封装了每个算法；<br>3.这族的算法可互换代替（interchangeable）。<br> <a href="https://zh.wikipedia.org/wiki/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">维基百科-策略模式</a></p></div><p class="readmore"><a href="/2018/01/29/策略模式/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2018/01/29/简单工厂模式/">简单工厂模式</a></h1><div class="post-meta">2018-01-29</div><div class="post-content"><blockquote>
<p>普通的工厂方法模式通常伴随着对象的具体类型与工厂具体类型的一一对应，客户端代码根据需要选择合适的具体类型工厂使用。然而，这种选择可能包含复杂的逻辑。这时，可以创建一个单一的工厂类，用以包含这种选择逻辑，根据参数的不同选择实现不同的具体对象。这个工厂类不需要由每个具体产品实现一个自己的具体的工厂类，所以可以将工厂方法设置为静态方法。 而且，工厂方法封装了对象的创建过程。如果创建过程非常复杂（比如依赖于配置文件或用户输入），工厂方法就非常有用了。 <a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95#简单工厂" target="_blank" rel="noopener">维基百科-简单工厂</a></p></div><p class="readmore"><a href="/2018/01/29/简单工厂模式/">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2018/01/29/Test/">Hexo+GitHub搭建自己的个人博客(尚未完成)</a></h1><div class="post-meta">2018-01-29</div><div class="post-content"><p><strong>目标：使用hexo+github搭建个人博客，并使用markdown写文章。</strong></p>
<ul>
<li>了解 <strong>hexo</strong>请移步 <a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">hexo中文站</a></li></div><p class="readmore"><a href="/2018/01/29/Test/">阅读全文</a></p></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blog.codingservice.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/GOF/">GOF</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Newtonsoft-Json/">Newtonsoft.Json</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/其他/">其他</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/其他/" style="font-size: 15px;">其他</a> <a href="/tags/Newtonsoft-Json/" style="font-size: 15px;">Newtonsoft.Json</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a title="暂无" target="_blank">暂无</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">CoderDp</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>